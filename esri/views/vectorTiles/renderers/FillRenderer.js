// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See http://js.arcgis.com/4.2/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/vectorTiles/renderers/shaders/solidFillShader.vs.glsl":"attribute vec2 a_pos;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\n\r\nvoid main()\r\n{\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0, 1.0);\r\n}\r\n","url:esri/views/vectorTiles/renderers/shaders/solidFillShader.fs.glsl":"uniform lowp vec4 u_color;\r\nvoid main()\r\n{\r\n  gl_FragColor \x3d u_color;\r\n}",
"url:esri/views/vectorTiles/renderers/shaders/patternFillShader.vs.glsl":"uniform highp mat4 u_transformMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\nuniform mediump mat3 u_pattern_matrix; // can we use meduim precision??\r\n\r\nattribute vec2 a_pos;\r\n\r\nvarying mediump vec2 v_tileTextureCoord;\r\n\r\nvoid main()\r\n{\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0);\r\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\r\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\r\n  // (-4k to 8k -1) to texture coordinates.\r\n  v_tileTextureCoord \x3d (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/patternFillShader.fs.glsl":"uniform lowp float u_opacity;\r\nuniform mediump vec2 u_pattern_tl;\r\nuniform mediump vec2 u_pattern_br;\r\nuniform sampler2D u_texture;\r\n\r\nvarying mediump vec2 v_tileTextureCoord;\r\n\r\nvoid main()\r\n{\r\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\r\n  mediump vec2 normalizedTextureCoord \x3d mod(v_tileTextureCoord, 1.0);\r\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\r\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\r\n  // we need to only sample from area that has our sprite in the mosaic.\r\n  mediump vec2 samplePos \x3d mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\r\n  // sample the sprite mosaic\r\n  lowp vec4 color \x3d texture2D(u_texture, samplePos);\r\n  gl_FragColor \x3d u_opacity * color;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/fillOutlineShader.vs.glsl":"attribute vec2 a_pos;\r\nattribute vec2 a_offset;\r\nattribute vec2 a_xnormal;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp mat4 u_extrudeMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\nuniform mediump float u_outline_width;\r\n\r\nvarying lowp vec2 v_normal;\r\n\r\nconst float scale \x3d 1.0 / 15.0;\r\n\r\nvoid main()\r\n{\r\n  v_normal \x3d a_xnormal;\r\n\r\n   // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\r\n    // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\r\n  mediump vec4 dist \x3d vec4(u_outline_width * a_offset * scale, 0.0, 0.0);\r\n\r\n  // Remove the texture normal bit of the position before scaling it with the\r\n  // model/view matrix. Add the extrusion vector *after* the model/view matrix\r\n  // because we're extruding the line in pixel space, regardless of the current\r\n  // tile's zoom level.\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * dist;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/fillOutlineShader.fs.glsl":"uniform lowp vec4 u_color;\r\nvarying mediump vec2 v_normal;\r\n\r\nvoid main()\r\n{\r\n  // Calculate the distance of the pixel from the line in pixels.\r\n  lowp float dist \x3d abs(v_normal.y);\r\n\r\n  lowp float alpha \x3d smoothstep(1.0, 0.0, dist);\r\n  gl_FragColor \x3d alpha * u_color;\r\n}\r\n"}});
define("require exports ../../../core/libs/gl-matrix/mat4 ../../../core/libs/gl-matrix/mat3 ../../../core/libs/gl-matrix/vec4 ../../../core/libs/gl-matrix/vec3 dojo/text!./shaders/solidFillShader.vs.glsl dojo/text!./shaders/solidFillShader.fs.glsl dojo/text!./shaders/patternFillShader.vs.glsl dojo/text!./shaders/patternFillShader.fs.glsl dojo/text!./shaders/fillOutlineShader.vs.glsl dojo/text!./shaders/fillOutlineShader.fs.glsl ../../webgl/Program ../../webgl/VertexArrayObject ../GeometryUtils".split(" "),function(K,
L,x,z,u,C,D,E,F,G,H,I,t,A,B){var J=1/65536;return function(){function l(){this._outlineAttributeLocations={a_pos:0,a_offset:1,a_xnormal:2};this._fillAttributeLocations={a_pos:0};this._initialized=!1;this._viewProjMat=x.create();this._offsetVector=C.create();this._patternMatrix=z.create();this._color=u.create();this._outlineColor=u.create()}l.prototype.render=function(a,c,b,e,p,g,h,l,t,v,f){this._initialized||this._initialize(a);var k=h.getPaintValue("fill-pattern",b),q=void 0!==k;if(!(q&&0===p)){var u=
h.getPaintValue("fill-antialias",b)&&!q;f*=h.getPaintValue("fill-opacity",b);var r=h.getPaintValue("fill-color",b),w=!1;if(!q){var d=r[3]*f;1===d&&0===p&&(w=!0);1>d&&1===p&&(w=!0)}if(w||0!==p){var m=g.tileTransform.transform,d=g.coordRange/512,n=h.getPaintValue("fill-translate",b);if(0!==n[0]||0!==n[1]){x.copy(this._viewProjMat,g.tileTransform.transform);var m=n[0],n=n[1],y=0,s=0,d=(1<<g.key.level)/Math.pow(2,b)*d;1===h.getPaintValue("fill-translate-anchor",b)?(s=Math.sin(B.C_DEG_TO_RAD*-e),e=Math.cos(B.C_DEG_TO_RAD*
-e),y=d*(m*e-n*s),s=d*(m*s+n*e)):(y=d*m,s=d*n);this._offsetVector[0]=y;this._offsetVector[1]=s;this._offsetVector[2]=0;x.translate(this._viewProjMat,this._viewProjMat,this._offsetVector);m=this._viewProjMat}if(e=this._getTrianglesVAO(a,g)){if(q){if(1===p&&(k=l.getMosaicItemPosition(k,!0)))d=g.coordRange/512/Math.pow(2,Math.round(b)-g.key.level)/v,z.identity(this._patternMatrix),q=1/(k.size[1]*d),this._patternMatrix[0]=1/(k.size[0]*d),this._patternMatrix[4]=q,a.bindVAO(e),l.bind(a,9729,0),a.bindProgram(this._patternFillProgram),
this._patternFillProgram.setUniformMatrix4fv("u_transformMatrix",m),this._patternFillProgram.setUniform2fv("u_normalized_origin",g.tileTransform.displayCoord),this._patternFillProgram.setUniform1f("u_depth",h.z),this._patternFillProgram.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix),this._patternFillProgram.setUniform1f("u_opacity",f),this._patternFillProgram.setUniform2f("u_pattern_tl",k.tl[0],k.tl[1]),this._patternFillProgram.setUniform2f("u_pattern_br",k.br[0],k.br[1]),this._patternFillProgram.setUniform1i("u_texture",
0),a.drawElements(4,c.triangleElementCount,5125,12*c.triangleElementStart),a.bindVAO()}else w&&(d=r[3]*f,this._color[0]=d*r[0],this._color[1]=d*r[1],this._color[2]=d*r[2],this._color[3]=d,a.bindVAO(e),a.bindProgram(this._solidFillProgram),this._solidFillProgram.setUniformMatrix4fv("u_transformMatrix",m),this._solidFillProgram.setUniform2fv("u_normalized_origin",g.tileTransform.displayCoord),this._solidFillProgram.setUniform1f("u_depth",h.z+J),this._solidFillProgram.setUniform4fv("u_color",this._color),
a.drawElements(4,c.triangleElementCount,5125,12*c.triangleElementStart),a.bindVAO());if(u&&0<c.outlineElementCount&&1===p){b=h.getPaintValue("fill-outline-color",b);if(0===b[3]){if(1!==this._color[3])return;b=r}v=0.75/v;f*=b[3];this._outlineColor[0]=f*b[0];this._outlineColor[1]=f*b[1];this._outlineColor[2]=f*b[2];this._outlineColor[3]=f;if(f=this._getOutlineVAO(a,g))a.bindVAO(f),a.bindProgram(this._outlineProgram),this._outlineProgram.setUniformMatrix4fv("u_transformMatrix",m),this._outlineProgram.setUniformMatrix4fv("u_extrudeMatrix",
t),this._outlineProgram.setUniform2fv("u_normalized_origin",g.tileTransform.displayCoord),this._outlineProgram.setUniform1f("u_depth",h.z),this._outlineProgram.setUniform1f("u_outline_width",v),this._outlineProgram.setUniform4fv("u_color",this._outlineColor),a.drawElements(4,c.outlineElementCount,5125,12*c.outlineElementStart),a.bindVAO()}}}}};l.prototype._initialize=function(a){if(this._initialized)return!0;var c=new t(a,D,E,{a_pos:0});if(!c)return!1;var b=new t(a,F,G,this._fillAttributeLocations);
if(!b)return!1;a=new t(a,H,I,this._outlineAttributeLocations);this._solidFillProgram=c;this._patternFillProgram=b;this._trianglesVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]};this._outlineProgram=a;this._outlineVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:8,normalized:!1,divisor:0},{name:"a_xnormal",count:2,type:5120,offset:6,stride:8,
normalized:!1,divisor:0}]};return this._initialized=!0};l.prototype._getTrianglesVAO=function(a,c){if(c.polygonTrianglesVertexArrayObject)return c.polygonTrianglesVertexArrayObject;var b=c.polygonTrianglesVertexBuffer,e=c.polygonTrianglesIndexBuffer;if(!b||!e)return null;c.polygonTrianglesVertexArrayObject=new A(a,this._fillAttributeLocations,this._trianglesVertexAttributes,{geometry:b},e);return c.polygonTrianglesVertexArrayObject};l.prototype._getOutlineVAO=function(a,c){if(c.polygonOutlineVertexArrayObject)return c.polygonOutlineVertexArrayObject;
var b=c.polygonOutlinesVertexBuffer,e=c.polygonOutlinesIndexBuffer;if(!b||!e)return null;c.polygonOutlineVertexArrayObject=new A(a,this._outlineAttributeLocations,this._outlineVertexAttributes,{geometry:b},e);return c.polygonOutlineVertexArrayObject};return l}()});