// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See http://js.arcgis.com/4.2/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/HUDMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"HUDMaterialCommonVariables"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n\tuniform vec4 viewport;\r\n\tuniform vec3 camPos;\r\n\tuniform float pixelRatio;\r\n\tuniform vec2 screenOffset;\r\n\tuniform vec2 anchorPos;\r\n\tuniform float polygonOffset;\r\n\tuniform float cameraGroundRelative;\r\n\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tattribute vec2 $uv0;\r\n\tattribute vec4 $color;\r\n  attribute vec2 $size;\r\n  attribute vec4 $auxpos1;\r\n  attribute vec4 $auxpos2;\r\n\r\n\tvarying vec4 vcolor;\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n \tvarying vec4 vtc;\r\n#else\r\n\tvarying vec2 vtc;\r\n\tvarying vec2 vsize;\r\n\tuniform sampler2D framebufferTex;\r\n\tuniform vec3 markerColor;\r\n#endif\r\n\r\n$vvUniforms\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"matchPixelOrigin"\x3e\x3c![CDATA[\r\n\tvec4 matchPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\r\n\t\tvec2 xy \x3d vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\r\n\t\tvec2 pixelSz \x3d vec2(1.0) / widthHeight;\r\n\t\tvec2 ij \x3d floor((xy + .5 * pixelSz) * widthHeight);\r\n\t\tvec2 result \x3d ((ij * pixelSz) * 2.0 - vec2(1.0)) * clipCoord.w;\r\n\t\treturn vec4(result.x, result.y, clipCoord.z, clipCoord.w);\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"calcPosMatchPixelCenter"\x3e\x3c![CDATA[\r\n\r\n\t\tvec3 posModel \x3d (model * vec4($position, 1.0)).xyz;\r\n\t\tvec3 posView \x3d (view * vec4(posModel, 1.0)).xyz;\r\n\r\n\t\tvec3 vnormal \x3d (modelNormal * vec4($normal, 1.0)).xyz;\r\n\r\n\t\t// groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise\r\n\t\tfloat groundRelative \x3d cameraGroundRelative * sign(pointGroundDistance);\r\n\t\tif (groundRelative \x3d\x3d 0.0) groundRelative \x3d 1.0;\r\n\r\n\t\t// view angle dependent part of polygon offset emulation\r\n\t\t// we take the absolute value because the sign that is dropped is\r\n\t\t// instead introduced using the ground-relative position of the symbol and the camera\r\n\t\tfloat cosAlpha \x3d abs(dot(vnormal, normalize(camPos - posModel)));\r\n\t\tif (cosAlpha \x3e .01 \x26\x26 polygonOffset \x3e .0) {\r\n\t\t\tfloat tanAlpha \x3d sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\r\n\t\t\tfloat factor \x3d (1.0 - tanAlpha / viewport[2]);\r\n\t\t\t// same side of the terrain\r\n\t\t\tif (groundRelative \x3e 0.0) {\r\n\t\t\t\tposView *\x3d factor;\r\n\t\t\t}\r\n\t\t\t// opposite sides of the terrain\r\n\t\t\telse {\r\n\t\t\t\tposView /\x3d factor;\r\n\t\t\t}\r\n\t\t}\r\n\r\n    \tposView +\x3d centerOffset;\r\n\r\n\t\tvec4 posProj \x3d proj * vec4(posView, 1.0);\r\n\r\n\t\t// constant part of polygon offset emulation\r\n\t\tposProj.z -\x3d groundRelative * polygonOffset * posProj.w;\r\n\r\n\t\tposProjCenter \x3d matchPixelCenter(posProj, viewport.zw);\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUD"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\t$vvFunctions\r\n\r\n\tvoid main(void) {\r\n\r\n\t\tvec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n\r\n#ifdef VV_SIZE\r\n\t\tvec2 inputSize \x3d vvGetScale($auxpos2).xy * $size;\r\n#else\r\n\t\tvec2 inputSize \x3d $size;\r\n#endif\r\n\r\n\t\tvec2 combinedSize \x3d inputSize * pixelRatio;\r\n\r\n\t\tvec4 posProjCenter;\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\t\t\tvec2 uv01 \x3d floor($uv0);\r\n\t\t\tvec2 uv \x3d $uv0 - uv01;\r\n\t\t\tfloat dist \x3d distance(camPos, posModel);\r\n\t\t\tposProj.xy +\x3d ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffset)/ viewport.zw * posProj.w;\r\n\t\t\tvtc.xy \x3d uv;\r\n\t\t\tvsize \x3d inputSize;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tgl_Position \x3d matchPixelOrigin(posProj, viewport.zw);\r\n\r\n#ifdef VV_COLOR\r\n\t\tvcolor \x3d vvGetColor($auxpos2, vvColorValues, vvColorColors);\r\n#else\r\n\t\tvcolor \x3d $color / 255.0;\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDWorldScale"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\tuniform vec2 minMaxWorldSizeFactor;\r\n\r\n\t$matchPixelCenter\r\n\t$vvFunctions\r\n\r\n\tvoid main(void) {\r\n\t\tvec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n#ifdef VV_SIZE\r\n\t\tvec2 combinedSize \x3d vvGetScale($auxpos2).xy * $size;\r\n#else\r\n\t\tvec2 combinedSize \x3d $size;\r\n#endif\r\n\r\n\t\tvec4 posProjCenter;\r\n\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\t\t\tfloat scale \x3d 1.0;\r\n\t\t\tvec2 minMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\r\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\r\n\t\t\t\tscale \x3d minMaxWorldSize.x / combinedSize.y;\r\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\r\n\t\t\t\tscale \x3d min(1.0, minMaxWorldSize.y / combinedSize.y);\r\n\r\n\t\t\tvec2 uv01 \x3d floor($uv0);\r\n\t\t\tvec2 uv \x3d $uv0 - uv01;\r\n\t\t\tposView.xy +\x3d (uv01 - anchorPos) * combinedSize * scale;\r\n\t\t\tvtc.xy \x3d uv;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tposProj \x3d proj * vec4(posView,1.0);\r\n\t\tposProj.xy +\x3d screenOffset / viewport.zw * posProj.w;\r\n\t\tgl_Position \x3d posProj;\r\n\r\n#ifdef VV_COLOR\r\n\t\tvcolor \x3d vvGetColor($auxpos2, vvColorValues, vvColorColors);\r\n#else\r\n\t\tvcolor \x3d $color / 255.0;\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\r\n\x3csnippet name\x3d"calcLabelDirections"\x3e\x3c![CDATA[\r\n\tvec2 uv01 \x3d floor($uv0);\r\n\tvec2 uv \x3d $uv0 - uv01;\r\n\r\n\tvec3 labelDir, labelDirOrtho;\r\n\r\n\tint isUp \x3d 0;\r\n\tvec2 vId \x3d (uv01 - vec2(.5, .5))*2.0;\r\n\r\n\tvec3 viewDirInNormalPlane \x3d normalize(camDir.xyz - dot(camDir.xyz, direction)*direction);\r\n\tfloat angleToNormal \x3d abs(dot(viewDirInNormalPlane,up));\r\n\tfloat angleToDirection \x3d abs(dot(camDir.xyz, direction));\r\n\tif (angleToDirection \x3c 0.985 \x26\x26 angleToNormal \x3c 0.500)\r\n\t{\r\n\t    if (angleToNormal \x3c 0.422) {\r\n\t\t    isUp \x3d 1;\r\n\t\t    labelDir \x3d direction;\r\n\t\t    labelDirOrtho \x3d up;\r\n\t\t    vId.y +\x3d 0.5;\r\n\t\t} else {\r\n\t\t    labelDir \x3d direction;\r\n            labelDirOrtho \x3d cross(viewDirInNormalPlane, direction);\r\n            vId.y +\x3d dot(labelDirOrtho, up)*0.5;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlabelDir \x3d direction;\r\n\t\tlabelDirOrtho \x3d normalize(cross(up,direction));\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDDirection"\x3e\x3c![CDATA[\r\n  $HUDMaterialCommonVariables\r\n  uniform vec3 direction;\r\n\r\n  $matchPixelCenter\r\n\t$vvFunctions\r\n\r\n\tvoid main(void) {\r\n\t\tvec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n#ifdef VV_SIZE\r\n\t\tvec2 inputSize \x3d vvGetScale($auxpos2).xy * $size;\r\n#else\r\n\t\tvec2 inputSize \x3d $size;\r\n#endif\r\n\t\tvec2 combinedSize \x3d inputSize * pixelRatio;\r\n\r\n        vec4 posProjCenter;\r\n \t\t$calcPosMatchPixelCenter\r\n\r\n \t\tvec3 up \x3d vnormal;\r\n \t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\r\n\r\n #ifdef OCCL_TEST\r\n \t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n #endif\r\n\r\n \t\t\t$calcLabelDirections\r\n\r\n\t\t    float scale;\r\n\t\t    if (proj[2][3] !\x3d 0.0)  // perspective projection\r\n \t\t\t    scale \x3d posProj.w*0.5/viewport[2];\r\n \t\t\telse                    // othographic projection\r\n \t\t\t    scale \x3d 2.0/proj[0][0]/viewport[2];\r\n\r\n \t\t\tposModel.xyz +\x3d labelDir * vId.x * combinedSize.x * scale ;\r\n \t\t\tposModel.xyz +\x3d labelDirOrtho * vId.y * combinedSize.y * scale;\r\n\r\n      // capability to flip upside down was lost when label texture atlases were implemented. this was the old code:\r\n \t\t\t//vec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\r\n \t\t\t//vec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\r\n \t\t\t//if (posDirProj.x \x3c posProjUnmodified.x)\r\n \t\t\t//{\r\n \t\t\t//\tif (isUp\x3d\x3d1)\r\n \t\t\t//\t\tuv.x \x3d texScale.x-uv.x;\r\n \t\t\t//\telse\r\n \t\t\t//\t\tuv \x3d texScale-uv;\r\n \t\t\t//}\r\n \t\t\tvtc.xy \x3d uv;\r\n #ifdef OCCL_TEST\r\n \t\t} else {\r\n \t\t\tvtc \x3d vec2(.0);\r\n \t\t}\r\n #endif\r\n\r\n #ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n \t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\r\n \t\tgl_Position \x3d pos4;\r\n\r\n#ifdef VV_COLOR\r\n\t\tvcolor \x3d vvGetColor($auxpos2, vvColorValues, vvColorColors);\r\n#else\r\n\t\tvcolor \x3d $color / 255.0;\r\n#endif\r\n \t}\r\n ]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDDirectionWorldScale"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\tuniform vec2 minMaxWorldSizeFactor;\r\n\tuniform vec3 direction;\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\t$vvFunctions\r\n\r\n\tvoid main(void) {\r\n\t\tvec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n#ifdef VV_SIZE\r\n\t\tvec2 combinedSize \x3d vvGetScale($auxpos2).xy * $size;\r\n#else\r\n\t\tvec2 combinedSize \x3d $size;\r\n#endif\r\n\r\n\t\tvec4 posProjCenter;\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n\t\tvec3 up \x3d vnormal;\r\n\t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\r\n\t\t\t$calcLabelDirections\r\n\r\n\t\t\tfloat scale \x3d 1.0;\r\n\t\t\tvec2 minMaxWorldSize \x3d minMaxWorldSizeFactor;\r\n\t\t\tif (proj[2][3] !\x3d 0.0)  // perspective projection\r\n\t\t\t\tminMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\r\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\r\n\t\t\t\tscale \x3d 0.5 * minMaxWorldSize.x / combinedSize.y;\r\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\r\n\t\t\t\tscale \x3d 0.5 * min(1.0, minMaxWorldSize.y / combinedSize.y);\r\n\r\n\t\t\tposModel.xyz +\x3d labelDir*vId.x*combinedSize.x*scale;\r\n\t\t\tposModel.xyz +\x3d labelDirOrtho*vId.y*combinedSize.y*scale;\r\n\r\n      // capability to flip upside down was lost when label texture atlases were implemented. this was the old code:\r\n\t\t\t//vec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\r\n\t\t\t//vec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\r\n \t\t\t//if (posDirProj.x\x3cposProjUnmodified.x)\r\n \t\t\t//{\r\n \t\t\t//\tif (isUp\x3d\x3d1)\r\n \t\t\t//\t\tuv.x \x3d texScale.x-uv.x;\r\n \t\t\t//\telse\r\n \t\t\t//\t\tuv \x3d texScale-uv;\r\n \t\t\t//}\r\n \t\t\t//uv.y +\x3d (1.0 - texScale.y);\r\n\t\t\tvtc.xy \x3d uv;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\r\n\t\tgl_Position \x3d pos4;\r\n\r\n#ifdef VV_COLOR\r\n\t\tvcolor \x3d vvGetColor($auxpos2, vvColorValues, vvColorColors);\r\n#else\r\n\t\tvcolor \x3d $color / 255.0;\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDBase"\x3e\x3c![CDATA[\r\n\tprecision mediump float;\r\n\r\n\t#extension GL_OES_standard_derivatives : require\r\n\r\n\tuniform sampler2D tex;\r\n\tuniform vec4 overrideColor;\r\n\tuniform vec4 outlineColor;\r\n\tuniform float outlineSize;\r\n\r\n\tvarying vec4 vcolor;\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvarying vec4 vtc;\r\n\tuniform vec3 markerColor;\r\n\tuniform sampler2D framebufferTex;\r\n#else\r\n\tvarying vec2 vtc;\r\n\tvarying vec2 vsize;\r\n#endif\r\n\r\n\tvoid main() {\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n   \t\tif (texture2D(framebufferTex, vtc.zw).rgb !\x3d markerColor)\r\n   \t\t\tdiscard;\r\n#endif\r\n\r\n#ifdef SIGNED_DISTANCE_FIELD\r\n\t\tvec4 color \x3d vec4(0.0, 0.0, 0.0, 0.0);\r\n\t\tvec4 fillPixelColor \x3d overrideColor * vcolor;\r\n\r\n\t\t// Attempt to sample texel centers to avoid thin cross outline\r\n\t\t// disappearing with large symbol sizes.\r\n\t\t// see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041\r\n\t\tconst float txSize \x3d 128.0;\r\n\t\tvec2 scaleFactor \x3d ((vsize - txSize) / txSize);\r\n\t\tvec2 samplePos \x3d vtc + vec2(1.0, -1.0) * (1.0 / txSize) * scaleFactor;\r\n\r\n\t\t// Distance in [-0.5, 0.5]\r\n\t\tfloat d \x3d dot(texture2D(tex, samplePos), vec4(1.0/16777216.0, 1.0/65535.0, 1.0/256.0, 1.0)) - 0.5;\r\n\r\n\t\t// Work around loss of precision for \'d \x3d 0.0\'.\r\n\t\t// \'0\' gets normalised to 0.5 * 256 \x3d 128 before float packing, but can only\r\n\t\t// be stored in the texture as 128 / 255 \x3d 0.502.\r\n\t\t// see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603110\r\n\t\tconst float diff \x3d (128.0/255.0 - 0.5);\r\n\r\n\t\t// adjust all values, not just those close to 0, to avoid discontinuities in\r\n\t\t// the outlines of other shapes e.g. circles\r\n\t\td \x3d d - diff;\r\n\r\n\t\t// Distance in output units\r\n\t\tfloat dist \x3d d * vsize.x;\r\n\r\n\t\tfillPixelColor.a *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n\t\tif (outlineSize \x3e 0.25) {\r\n\t\t\tvec4 outlinePixelColor \x3d outlineColor;\r\n\t\t\tfloat clampedOutlineSize \x3d min(outlineSize, 0.5*vsize.x);\r\n\t\t\toutlinePixelColor.a *\x3d clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\r\n\r\n\t\t\t// perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\r\n\t\t\tfloat compositeAlpha \x3d outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\t\t\tvec3 compositeColor \x3d vec3(outlinePixelColor) * outlinePixelColor.a +\r\n\t\t\t\tvec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\t\t\tcompositeColor /\x3d compositeAlpha;\r\n\r\n\t\t\tgl_FragColor \x3d vec4(compositeColor, compositeAlpha);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tgl_FragColor \x3d fillPixelColor;\r\n\t\t}\r\n\r\n\t\t// visualize SDF:\r\n\t\t// gl_FragColor \x3d vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\r\n#else\r\n\t\tgl_FragColor \x3d texture2D(tex, vtc, -0.5) * overrideColor * vcolor;\r\n#endif\r\n\r\n\t\tif (gl_FragColor.a \x3c 0.1) {\r\n\t\t\tdiscard;\r\n\t\t}\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUD"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBase\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDHighlight"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBase\r\n  gl_FragColor \x3d vec4(1.0, 1.0, 1.0, 1.0);\r\n}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderOcclusionTestPixel"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n\tuniform vec4 viewport;\r\n\tuniform vec3 camPos;\r\n\tuniform float polygonOffset;\r\n\tuniform float cameraGroundRelative;\r\n\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tattribute vec4 $auxpos1;\r\n\r\n\t$matchPixelCenter\r\n\r\n\tvoid main(void) {\r\n\t    vec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n\r\n\t    vec4 posProjCenter;\r\n\t    if (dot($position, $position) \x3e 0.0) {\r\n\t\t    $calcPosMatchPixelCenter\r\n\t\t} else {\r\n\t\t    posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\r\n\t\t}\r\n\r\n\t\tgl_Position \x3d posProjCenter;\r\n\t\tgl_PointSize \x3d 1.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("dojo/_base/lang dojo/text!./HUDMaterial.xml ./internal/MaterialUtil ../lib/ShaderVariations ../lib/Util ../lib/gl-matrix ../lib/RenderSlot ../../../webgl/Program ../lib/DefaultVertexAttributeLocations ../../../webgl/Util".split(" "),function(H,K,s,I,x,C,D,L,M,w){var J=C.vec2d,A=C.vec3d,E=C.mat4d,B=x.assert,h=x.VertexAttrConstants,F={"bottom-left":[0,0],bottom:[0.5,0],"bottom-right":[1,0],left:[0,0.5],center:[0.5,0.5],right:[1,0.5],"top-left":[0,1],top:[0.5,1],"top-right":[1,1]},y=[253/255,
231/255,229/255];x=function(c,G){s.basicMaterialConstructor(this,G);c=c||null;c.texCoordScale=c.texCoordScale||[1,1];c.occlusionTest=void 0!==c.occlusionTest?c.occlusionTest:!0;c.color=c.color||[1,1,1,1];c.screenMinMaxSize=c.screenMinMaxSize||[0,1E5];c.outlineColor=c.outlineColor||[1,1,1,1];c.outlineSize=c.outlineSize||0;c.textureIsSignedDistanceField=c.textureIsSignedDistanceField?1:0;c.distanceFieldBoundingBox=c.distanceFieldBoundingBox||[0.25,0.25,0.75,0.75];c.vvSizeEnabled=c.vvSizeEnabled||!1;
c.vvSizeMinDataValue=c.vvSizeMinDataValue||[0,0,0];c.vvSizeMinSize=c.vvSizeMinSize||[1,1,1];c.vvSizeMaxDataValue=c.vvSizeMaxDataValue||[0,0,0];c.vvSizeMaxSize=c.vvSizeMaxSize||[100,100,100];c.vvColorEnabled=c.vvColorEnabled||!1;c.vvColorValues=c.vvColorValues||[0,0,0,0,0,0,0,0];c.vvColorColors=c.vvColorColors||[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0];c.screenOffset?c.screenOffset.forEach(function(b,m){c.screenOffset[m]=2*b}):c.screenOffset=[0,0];"string"===typeof c.anchorPos?
(B(F[c.anchorPos],"HUDMaterial: invalid anchorPos specified"),c.anchorPos=F[c.anchorPos]):c.anchorPos||(c.anchorPos=F.center);null==c.shaderPolygonOffset&&(c.shaderPolygonOffset=1E-5);var u=[{name:"position",count:3,type:5126,offset:0,stride:76,normalized:!1},{name:"normal",count:3,type:5126,offset:12,stride:76,normalized:!1},{name:"uv0",count:2,type:5126,offset:24,stride:76,normalized:!1},{name:"color",count:4,type:5121,offset:32,stride:76,normalized:!1},{name:"size",count:2,type:5126,offset:36,
stride:76,normalized:!1},{name:"auxpos1",count:4,type:5126,offset:44,stride:76,normalized:!1},{name:"auxpos2",count:4,type:5126,offset:60,stride:76,normalized:!1}],q=w.getStride(u),d=q/4;this.dispose=function(){};this.getParameterValues=function(){var b={color:c.color,texCoordScale:c.texCoordScale,polygonOffset:c.polygonOffset,anchorPos:c.anchorPos,screenOffset:c.screenOffset,screenMinMaxSize:c.screenMinMaxSize,shaderPolygonOffset:c.shaderPolygonOffset,textureIsSignedDistanceField:c.textureIsSignedDistanceField,
outlineColor:c.outlineColor,outlineSize:c.outlineSize,distanceFieldBoundingBox:c.distanceFieldBoundingBox,vvSizeEnabled:c.vvSizeEnabled,vvSizeMinDataValue:c.vvSizeMinDataValue,vvSizeMinSize:c.vvSizeMinSize,vvSizeMaxDataValue:c.vvSizeMaxDataValue,vvSizeMaxSize:c.vvSizeMaxSize,vvColorEnabled:c.vvColorEnabled,vvColorValues:c.vvColorValues,vvColorColors:c.vvColorColors};c.textureId&&(b.textureId=c.textureId);c.direction&&(b.direction=c.direction);return b};this.setParameterValues=function(b){for(var m in b)"textureId"===
m&&B(c.textureId,"Can only change texture of material that already has a texture"),"direction"===m&&B(c.direction,"Can only change direction of HUDMaterial which was initialized with a direction"),c[m]=b[m];this.notifyDirty("matChanged")};this.getParams=function(){return c};this.getOutputAmount=function(c){return 6*c*d};this.getVertexBufferLayout=function(){return u};this.fillInterleaved=function(b,m,k,f,e,n){var l=4*n;f=s.fill;for(var r=b.faces.indices[h.POSITION],v=b.vertexAttr[h.POSITION].data,
a=n+w.findAttribute(u,h.POSITION).offset/4,p=0;p<r.length;++p){var g=3*r[p];f(v,g,e,a,m,3);a+=d;f(v,g,e,a,m,3);a+=d;f(v,g,e,a,m,3);a+=d;f(v,g,e,a,m,3);a+=d;f(v,g,e,a,m,3);a+=d;f(v,g,e,a,m,3);a+=d}m=b.faces.indices[h.NORMAL];v=b.vertexAttr[h.NORMAL].data;a=n+w.findAttribute(u,h.NORMAL).offset/4;for(p=0;p<m.length;++p)g=3*m[p],f(v,g,e,a,k,3),a+=d,f(v,g,e,a,k,3),a+=d,f(v,g,e,a,k,3),a+=d,f(v,g,e,a,k,3),a+=d,f(v,g,e,a,k,3),a+=d,f(v,g,e,a,k,3),a+=d;a=n+w.findAttribute(u,h.UV0).offset/4;p=b.vertexAttr[h.UV0].data;
null==p||3>=p.length?(k=g=0,m=c.texCoordScale[0],v=c.texCoordScale[1]):(g=b.vertexAttr[h.UV0].data[0],k=b.vertexAttr[h.UV0].data[1],m=b.vertexAttr[h.UV0].data[2],v=b.vertexAttr[h.UV0].data[3]);m=Math.min(1.99999,m+1);v=Math.min(1.99999,v+1);for(p=0;p<r.length;++p)e[a]=g,e[a+1]=k,a+=d,e[a]=m,e[a+1]=k,a+=d,e[a]=m,e[a+1]=v,a+=d,e[a]=m,e[a+1]=v,a+=d,e[a]=g,e[a+1]=v,a+=d,e[a]=g,e[a+1]=k,a+=d;r=b.faces.indices[h.COLOR];k=b.vertexAttr[h.COLOR].data;a=l+w.findAttribute(u,h.COLOR).offset;l=new Uint8Array(e.buffer);
for(p=0;p<r.length;++p)g=4*r[p],f(k,g,l,a,null,4),a+=q,f(k,g,l,a,null,4),a+=q,f(k,g,l,a,null,4),a+=q,f(k,g,l,a,null,4),a+=q,f(k,g,l,a,null,4),a+=q,f(k,g,l,a,null,4),a+=q;l=b.faces.indices[h.SIZE];g=b.vertexAttr[h.SIZE].data;a=n+w.findAttribute(u,h.SIZE).offset/4;for(p=0;p<l.length;++p)r=g[2*l[p]],k=g[2*l[p]+1],e[a]=r,e[a+1]=k,a+=d,e[a]=r,e[a+1]=k,a+=d,e[a]=r,e[a+1]=k,a+=d,e[a]=r,e[a+1]=k,a+=d,e[a]=r,e[a+1]=k,a+=d,e[a]=r,e[a+1]=k,a+=d;if(null!=b.faces.indices[h.AUXPOS1]&&null!=b.vertexAttr[h.AUXPOS1]){l=
b.faces.indices[h.AUXPOS1];r=b.vertexAttr[h.AUXPOS1].data;a=n+w.findAttribute(u,"auxpos1").offset/4;for(p=0;p<l.length;++p)g=4*l[p],f(r,g,e,a,null,4),a+=d,f(r,g,e,a,null,4),a+=d,f(r,g,e,a,null,4),a+=d,f(r,g,e,a,null,4),a+=d,f(r,g,e,a,null,4),a+=d,f(r,g,e,a,null,4),a+=d}if(null!=b.faces.indices[h.AUXPOS2]&&null!=b.vertexAttr[h.AUXPOS2]){l=b.faces.indices[h.AUXPOS2];b=b.vertexAttr[h.AUXPOS2].data;a=n+w.findAttribute(u,"auxpos2").offset/4;for(p=0;p<l.length;++p)g=4*l[p],f(b,g,e,a,null,4),a+=d,f(b,g,
e,a,null,4),a+=d,f(b,g,e,a,null,4),a+=d,f(b,g,e,a,null,4),a+=d,f(b,g,e,a,null,4),a+=d,f(b,g,e,a,null,4),a+=d}};var z=A.create(),l=A.create(),b=E.create();E.identity(b);var n=[0,0];this.intersect=function(d,m,k,f,e,u,G,r){if(f.isSelection&&f.enableHUDSelection){e=m=1;r&&(e=r(b),m=e[0],e=e[5]);r=d.getData().getVertexAttr()[h.POSITION];d=d.getData().getVertexAttr()[h.SIZE];B(3<=r.size);u=f.point;var v=f.camera,a=f.p0;f=f.p1;for(var p=0;p<r.data.length/r.size;p++){var g=p*r.size;A.set3(r.data[g],r.data[g+
1],r.data[g+2],z);E.multiplyVec3(k,z,z);g=p*d.size;n[0]=d.data[g]*m;n[1]=d.data[g+1]*e;v.projectPoint(z,l);if(-1<l[0]){var q=c.anchorPos,g=l[0]-1-(0<q[0]?n[0]*q[0]:0),s=g+n[0],q=l[1]-1-(0<q[1]?n[1]*q[1]:0),w=q+n[1];if(c.textureIsSignedDistanceField)var x=c.distanceFieldBoundingBox,y=c.outlineSize/2,g=g+(n[0]*x[0]-y),s=s-(n[0]*(1-x[2])-y),q=q+(n[1]*x[1]-y),w=w-(n[1]*(1-x[3])-y);u[0]>g&&(u[0]<s&&u[1]>q&&u[1]<w)&&(g=A.subtract(a,z,A.create()),s=A.length(g),A.scale(g,1/s),s=0.98*s/A.dist(a,f),G(s,g,-1,
1,!0))}}}};this.getGLMaterials=function(){return{color:N,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:O}};this.getAllTextureIds=function(){return[c.textureId]};this._textureDirty=!1;this.setTextureDirty=function(){this._textureDirty=!0}};var N=function(c,h,u){function q(){return h.shaderVariators.HUDMaterial.getProgram([!!b.direction,!!b.worldScale,b.occlusionTest,b.textureIsSignedDistanceField,!!b.vvSizeEnabled,!!b.vvColorEnabled])}s.basicGLMaterialConstructor(this,c);var d=D.OCCLUSION_PIXELS,
z=D.OVERLAY,l=0,b=H.clone(c.getParams()),n=h.get("hudOcclusionTestPixel"),t=q();s.singleTextureGLMaterialConstructor(this,u,b);this.beginSlot=function(c){l=c;return b.occlusionTest?c===d||c===z:c===z};this.getProgram=function(){return l===d&&b.occlusionTest?n:t};this.getAllPrograms=function(){return[n,t]};this.updateParameters=function(){var d=c.getParams();b.color=d.color;b.texCoordScale=d.texCoordScale;b.polygonOffset=d.polygonOffset;b.anchorPos=d.anchorPos;b.screenOffset=d.screenOffset;b.screenMinMaxSize=
d.screenMinMaxSize;b.direction=d.direction;b.shaderPolygonOffset=d.shaderPolygonOffset;b.textureIsSignedDistanceField=d.textureIsSignedDistanceField;b.outlineColor=d.outlineColor;b.outlineSize=d.outlineSize;b.vvSizeEnabled=d.vvSizeEnabled;b.vvSizeMinDataValue=d.vvSizeMinDataValue;b.vvSizeMinSize=d.vvSizeMinSize;b.vvSizeMaxDataValue=d.vvSizeMaxDataValue;b.vvSizeMaxSize=d.vvSizeMaxSize;b.vvColorEnabled=d.vvColorEnabled;b.vvColorValues=d.vvColorValues;b.vvColorColors=d.vvColorColors;this.updateTexture(d.textureId);
t=q()};this.bind=function(m,k){c._textureDirty&&(this.renderTexture(m),c._textureDirty=!1);var f=m.gl,e=k.cameraAboveGround?1:-1;if(l===d&&b.occlusionTest)m.bindProgram(n),n.setUniform1f("cameraGroundRelative",e),n.setUniform1f("polygonOffset",b.shaderPolygonOffset),n.setUniform4fv("viewport",k.viewport),n.setUniform4f("color",y[0],y[1],y[2],1),m.setDepthFunction(f.LEQUAL);else{m.bindProgram(t);t.setUniform1f("cameraGroundRelative",e);this.bindTexture(m,t);t.setUniform1i("framebufferTex",1);m.bindTexture(k.framebufferTex,
1);m.setActiveTexture(0);t.setUniform3fv("markerColor",y);t.setUniform4fv("viewport",k.viewport);t.setUniform4fv("overrideColor",b.color);t.setUniform1f("pixelRatio",k.pixelRatio);t.setUniform1f("polygonOffset",b.shaderPolygonOffset);b.textureIsSignedDistanceField&&(t.setUniform4fv("outlineColor",b.outlineColor),t.setUniform1f("outlineSize",b.outlineSize));b.vvSizeEnabled&&(t.setUniform3fv("vvSizeMinDataValue",b.vvSizeMinDataValue),t.setUniform3fv("vvSizeMaxDataValue",b.vvSizeMaxDataValue),t.setUniform3fv("vvSizeMinSize",
b.vvSizeMinSize),t.setUniform3fv("vvSizeMaxSize",b.vvSizeMaxSize));b.vvColorEnabled&&(t.setUniform1fv("vvColorValues",b.vvColorValues),t.setUniform4fv("vvColorColors",b.vvColorColors));if(b.worldScale){var f=[-1,-1],e=b.screenMinMaxSize,h=k.proj,q=k.viewport[2]/k.pixelRatio;e&&(0!==h[11]?(h=2*Math.atan(1/h[0]),q=2*(Math.tan(h/2)/q),f[0]=e[0]*q,f[1]=e[1]*q):J.scale(e,2/(h[0]*q),f));t.setUniform2fv("minMaxWorldSizeFactor",f)}b.direction&&t.setUniform3fv("direction",b.direction);t.setUniform2fv("texScale",
b.texCoordScale);t.setUniform2fv("screenOffset",b.screenOffset);t.setUniform2fv("anchorPos",b.anchorPos);b.polygonOffset&&(m.setPolygonOffsetFillEnabled(!0),m.setPolygonOffset(0,-4));m.setBlendingEnabled(!0)}};this.release=function(c){var k=c.gl;l===d&&b.occlusionTest?c.setDepthFunction(k.LESS):(c.setPolygonOffsetFillEnabled(!1),c.setBlendingEnabled(!1))};this.bindView=function(c,k){var f=k.origin;l===d&&b.occlusionTest?(s.bindView(f,k.view,n),s.bindCamPos(f,k.viewInvTransp,n)):(s.bindView(f,k.view,
t),s.bindCamPos(f,k.viewInvTransp,t))};this.bindInstance=function(c,k){l===d&&b.occlusionTest?(n.setUniformMatrix4fv("model",k.transformation),n.setUniformMatrix4fv("modelNormal",k.transformationNormal)):t.setUniformMatrix4fv("model",k.transformation)};this.getDrawMode=function(c){c=c.gl;return l===d&&b.occlusionTest?c.POINTS:c.TRIANGLES}},O=function(c,h,u){function q(){return h.shaderVariators.HUDMaterialHighlight.getProgram([!!d.direction,!!d.worldScale,d.occlusionTest,d.textureIsSignedDistanceField,
!!d.vvSizeEnabled,!!d.vvColorEnabled])}s.basicGLMaterialConstructor(this,c);var d=H.clone(c.getParams()),z=h.get("hudOcclusionTestPixel"),l=q();s.singleTextureGLMaterialConstructor(this,u,d);this.beginSlot=function(b){return b===D.OVERLAY};this.getProgram=function(){return l};this.getAllPrograms=function(){return[z,l]};this.updateParameters=function(){var b=c.getParams();d.color=b.color;d.texCoordScale=b.texCoordScale;d.polygonOffset=b.polygonOffset;d.anchorPos=b.anchorPos;d.screenOffset=b.screenOffset;
d.screenMinMaxSize=b.screenMinMaxSize;d.direction=b.direction;d.shaderPolygonOffset=b.shaderPolygonOffset;d.textureIsSignedDistanceField=b.textureIsSignedDistanceField;d.outlineColor=b.outlineColor;d.outlineSize=b.outlineSize;this.updateTexture(b.textureId);l=q()};this.bind=function(b,n){c._textureDirty&&(this.renderTexture(b),c._textureDirty=!1);b.bindProgram(l);this.bindTexture(b,l);l.setUniform1i("framebufferTex",1);b.bindTexture(n.framebufferTex,1);b.setActiveTexture(0);l.setUniform3fv("markerColor",
y);l.setUniform4fv("viewport",n.viewport);l.setUniform4fv("overrideColor",d.color);l.setUniform1f("pixelRatio",n.pixelRatio);l.setUniform1f("polygonOffset",d.shaderPolygonOffset);d.textureIsSignedDistanceField&&(l.setUniform4fv("outlineColor",d.outlineColor),l.setUniform1f("outlineSize",d.outlineSize));if(d.worldScale){var h=[-1,-1],m=d.screenMinMaxSize,k=n.proj,f=n.viewport[2]/n.pixelRatio;m&&(0!==k[11]?(k=2*Math.atan(1/k[0]),f=2*(Math.tan(k/2)/f),h[0]=m[0]*f,h[1]=m[1]*f):J.scale(m,2/(k[0]*f),h));
l.setUniform2fv("minMaxWorldSizeFactor",h)}d.direction&&l.setUniform3fv("direction",d.direction);l.setUniform2fv("texScale",d.texCoordScale);l.setUniform2fv("screenOffset",d.screenOffset);l.setUniform2fv("anchorPos",d.anchorPos);d.polygonOffset&&(b.setPolygonOffsetFillEnabled(!0),b.setPolygonOffset(0,-4));b.setBlendingEnabled(!0)};this.release=function(b){b.setPolygonOffsetFillEnabled(!1);b.setBlendingEnabled(!1)};this.bindView=function(b,c){var d=c.origin;s.bindView(d,c.view,l);s.bindCamPos(d,c.viewInvTransp,
l)};this.bindInstance=function(b,c){l.setUniformMatrix4fv("model",c.transformation)};this.getDrawMode=function(b){return b.gl.TRIANGLES}};x.loadShaders=function(c,h,u,q){c._parse(K);var d=0<q.parameters.maxVertexTextureImageUnits,s=new I("hud",["vertexShaderHUD","fragmentShaderHUD"],null,u,h,c,q);s.addBinaryShaderSnippetSuffix("Direction","Direction",[!0,!1]);s.addBinaryShaderSnippetSuffix("WorldScale","WorldScale",[!0,!1]);s.addDefine("OcclTest",d?"OCCL_TEST":"OCCL_PIXELSHADER");s.addDefine("SDF",
"SIGNED_DISTANCE_FIELD");s.addDefine("vvSize","VV_SIZE");s.addDefine("vvColor","VV_COLOR");u.shaderVariators.HUDMaterial=s;h=new I("hudHighlight",["vertexShaderHUD","fragmentShaderHUDHighlight"],null,u,h,c,q);h.addBinaryShaderSnippetSuffix("Direction","Direction",[!0,!1]);h.addBinaryShaderSnippetSuffix("WorldScale","WorldScale",[!0,!1]);h.addDefine("OcclTest",d?"OCCL_TEST":"OCCL_PIXELSHADER");h.addDefine("SDF","SIGNED_DISTANCE_FIELD");h.addDefine("vvSize","VV_SIZE");h.addDefine("vvColor","VV_COLOR");
u.shaderVariators.HUDMaterialHighlight=h;c=new L(q,c.vertexShaderOcclusionTestPixel,c.fragmentShaderSimple,M.Default3D);u.add("hudOcclusionTestPixel",c)};return x});