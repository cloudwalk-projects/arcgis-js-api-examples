// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See http://js.arcgis.com/4.2/esri/copyright.txt for details.
//>>built
define("require exports ../../webgl-engine/lib/gl-matrix ../../../webgl/Program ../../../webgl/VertexArrayObject ../../../webgl/BufferObject ../../webgl-engine/lib/RenderPass ../../../webgl/enums".split(" "),function(q,r,d,f,l,h,g,s){var k={aPosition:0,aColor:1},m={positions:[{name:"aPosition",count:3,type:5126,offset:0,stride:12,normalized:!1}],colors:[{name:"aColor",count:3,type:5121,offset:0,stride:3,normalized:!0}]};return function(){function b(){this.didRender=!1;this.needsRender=!0;this._scaleFactor=
1;this._clipMin=d.vec3.createFrom(-Infinity,-Infinity,-Infinity);this._clipMax=d.vec3.createFrom(Infinity,Infinity,Infinity);this._program=null;this.tempMatrix4=d.mat4.create();this.tempVec2=d.vec2.create();this.tempVec3=d.vec3.create();this.addQueue=[];this.nodeRenderInfos=[]}b.prototype.initializeRenderContext=function(a){this._program=new f(a.rctx,"\n      attribute vec3 aPosition;\n      attribute vec3 aColor;\n\n      uniform mat4 uModelViewMatrix;\n      uniform mat4 uProjectionMatrix;\n      uniform vec2 uPointScale;\n      uniform vec3 uClipMin;\n      uniform vec3 uClipMax;\n\n      varying vec3 vColor;\n      void main(void) {\n\n        // Move clipped points outside of clipspace\n        if (min(aPosition, uClipMin) !\x3d uClipMin ||\n            max(aPosition, uClipMax) !\x3d uClipMax) {\n          vColor \x3d vec3(0.0);\n          gl_Position \x3d vec4(0.0,0.0,0.0,2.0);\n          gl_PointSize \x3d 0.0;\n          return;\n        }\n        \n        // Position in camera space\n        vec4 camera \x3d uModelViewMatrix * vec4(aPosition, 1.0);\n\n        // Shift towards camera\n        float pointRadius \x3d uPointScale.x;\n        camera.z +\x3d pointRadius;\n\n        vec4 position \x3d uProjectionMatrix * camera;\n        gl_Position \x3d position;\n\n        // Calculate Size\n        vec4 positionOffset \x3d uProjectionMatrix * (camera + vec4(0.0, pointRadius, 0.0, 0.0));\n        float radius \x3d abs(positionOffset.y - position.y);\n\n        float viewHeight \x3d uPointScale.y;\n        gl_PointSize \x3d radius / position.w * viewHeight; // (2 * r / w) * (h / 2)\n\n        vColor \x3d aColor;\n      }\n    ",
"\n      precision mediump float;\n      varying vec3 vColor;\n      void main(void) {\n\n        vec2 vOffset \x3d gl_PointCoord - vec2(0.5, 0.5);\n        float r2 \x3d dot(vOffset, vOffset);\n        if (r2 \x3e 0.25) {\n          discard;\n        }\n\n        gl_FragColor \x3d vec4(vColor, 1.0);\n      }\n    ",k);this.needsRender=!0};b.prototype.uninitializeRenderContext=function(a){this._program&&this._program.dispose();this._program=null};b.prototype.render=function(a){if(a.pass!==g.MATERIAL)return!1;
for(var c=a.rctx;this.addQueue.length;)this._initNode(a,this.addQueue.shift());if(null==this._program||0===this.nodeRenderInfos.length)return!0;c.setDepthTestEnabled(!0);c.bindProgram(this._program);this._program.setUniformMatrix4fv("uProjectionMatrix",a.camera.projectionMatrix);for(var b=0;b<this.nodeRenderInfos.length;b++){var e=this.nodeRenderInfos[b];this.tempVec2[0]=e.pointRadius*this._scaleFactor;this.tempVec2[1]=a.camera.fullHeight;this._program.setUniform2fv("uPointScale",this.tempVec2);d.vec3.subtract(this._clipMin,
e.origin,this.tempVec3);this._program.setUniform3fv("uClipMin",this.tempVec3);d.vec3.subtract(this._clipMax,e.origin,this.tempVec3);this._program.setUniform3fv("uClipMax",this.tempVec3);d.mat4.identity(this.tempMatrix4);d.mat4.translate(this.tempMatrix4,e.origin,this.tempMatrix4);d.mat4.multiply(a.camera.viewMatrix,this.tempMatrix4,this.tempMatrix4);this._program.setUniformMatrix4fv("uModelViewMatrix",this.tempMatrix4);c.bindVAO(e.vao);c.drawArrays(0,0,e.pointCount)}return!0};Object.defineProperty(b.prototype,
"scaleFactor",{get:function(){return this._scaleFactor},set:function(a){this._scaleFactor!==a&&(this._scaleFactor=a,this._requestRender())},enumerable:!0,configurable:!0});Object.defineProperty(b.prototype,"clippingBox",{set:function(a){null!=a?(d.vec3.set3(a[0],a[1],a[2],this._clipMin),d.vec3.set3(a[3],a[4],a[5],this._clipMax)):(d.vec3.set3(-Infinity,-Infinity,-Infinity,this._clipMin),d.vec3.set3(Infinity,Infinity,Infinity,this._clipMax))},enumerable:!0,configurable:!0});b.prototype.addNode=function(a){this.addQueue.push(a);
this._requestRender()};b.prototype.removeNode=function(a){this.nodeRenderInfos=this.nodeRenderInfos.filter(function(c){c.id===a&&(c.vao.dispose(!0),c.vao=null);return c.id!==a});this.addQueue=this.addQueue.filter(function(c){return c.id!==a});this._requestRender()};b.prototype.removeAll=function(){this.nodeRenderInfos.forEach(function(a){a.vao.dispose(!0);a.vao=null});this.nodeRenderInfos=[];this.addQueue=[];this._requestRender()};b.prototype._initNode=function(a,c){var b=a.rctx,e=c.coordinates,f=
d.vec3.createFrom(c.origin[0],c.origin[1],c.origin[2]),g=c.rgb,n=c.pointRadius,p=e.length/3,b=new l(b,k,m,{positions:h.createVertex(b,35044,e),colors:h.createVertex(b,35044,g)});this.nodeRenderInfos.push({id:c.id,origin:f,pointCount:p,pointRadius:n,vao:b})};b.prototype._requestRender=function(){this.didRender=!1;this.needsRender=!0};return b}()});